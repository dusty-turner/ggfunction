---
title: "Cross-Conversion Between Distribution Functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Cross-Conversion Between Distribution Functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 6,
  fig.height = 4
)
library(ggfunction)
library(patchwork)
```

## Motivation

A probability distribution is fully characterized by any one of its standard
functions: the PDF $f$, CDF $F$, survival function $S = 1 - F$, quantile
function $Q = F^{-1}$, or hazard function $h = f / S$. In R, base distribution
families provide all of these (e.g. `dnorm`, `pnorm`, `qnorm`), but
user-defined distributions or distributions from other packages may only supply
one or two.

**ggfunction** lets you pass whichever function type you have to whichever geom
you need. For example, if you have a PDF but want to plot the CDF, you can write
`geom_cdf(pdf_fun = my_pdf)` and the conversion happens automatically. This
vignette explains which conversions are available, how they work internally, and
what accuracy to expect.

## Available conversions

Each probability geom accepts its native function type via `fun` and one or more
alternate types via named parameters. The table below summarizes the routes:

| Geom | Native (`fun`) | Alternates |
|------|----------------|------------|
| `geom_pdf()` | PDF | `cdf_fun` (differentiate), `survival_fun` ($1 - S$ then differentiate), `qf_fun` (interpolate then differentiate), `hf_fun` ($f = h \cdot e^{-H}$) |
| `geom_cdf()` | CDF | `pdf_fun` (integrate), `survival_fun` ($1 - S$), `qf_fun` (interpolate), `hf_fun` (integrate hazard, $F = 1 - e^{-H}$) |
| `geom_survival()` | Survival | `cdf_fun` ($1 - F$), `pdf_fun` (integrate, then $1 - F$), `qf_fun` (interpolate, then $1 - F$) |
| `geom_qf()` | Quantile | `cdf_fun` (root-find), `pdf_fun` (integrate, then root-find), `survival_fun` ($1 - S$, then root-find) |
| `geom_hf()` | Hazard | `pdf_fun` + `cdf_fun` (ratio, or just one), `survival_fun` ($1 - S$ then differentiate), `qf_fun` (interpolate then differentiate) |
| `geom_chf()` | Cumulative hazard | `hf_fun` (integrate), `cdf_fun` ($-\log(1-F)$), `survival_fun` ($-\log S$), `pdf_fun` (integrate then $-\log(1-F)$), `qf_fun` (interpolate then $-\log(1-F)$) |
| `geom_cdf_discrete()` | CDF | `pmf_fun` (cumulative sum), `survival_fun` ($1 - S$) |
| `geom_survival_discrete()` | Survival | `cdf_fun` ($1 - F$), `pmf_fun` (cumsum, then $1 - F$) |
| `geom_qf_discrete()` | Quantile | `cdf_fun` (invert on support), `pmf_fun` (cumsum, then invert), `survival_fun` ($1 - S$, then invert) |

Exactly one function source must be provided; supplying more than one (e.g. both
`fun` and `pdf_fun`) is an error.

## Example: one PDF, four plots

Suppose you only have the PDF of a Gamma(2, 1) distribution:

```{r gamma-pdf}
my_pdf <- function(x, shape, rate) dgamma(x, shape = shape, rate = rate)
gamma_args <- list(shape = 2, rate = 1)
```

You can plot the PDF, CDF, survival function, and quantile function without ever
writing a CDF or quantile function yourself:

```{r gamma-four-views, fig.width = 10, fig.height = 8}
p1 <- ggplot() +
  geom_pdf(fun = my_pdf, xlim = c(0, 8), args = gamma_args) +
  ggtitle("PDF (native)")

p2 <- ggplot() +
  geom_cdf(pdf_fun = my_pdf, xlim = c(0, 8), args = gamma_args) +
  ggtitle("CDF (from PDF)")

p3 <- ggplot() +
  geom_survival(pdf_fun = my_pdf, xlim = c(0, 8), args = gamma_args) +
  ggtitle("Survival (from PDF)")

p4 <- ggplot() +
  geom_qf(pdf_fun = my_pdf, args = gamma_args) +
  ggtitle("Quantile (from PDF)")

(p1 | p2) / (p3 | p4)
```

## How the conversions work

Three internal helper functions perform the numerical conversions. They are not
exported, but understanding them helps set expectations for accuracy and
performance.

### PDF to CDF: numerical integration

Given a PDF $f$, the CDF is

$$F(x) = \int_{-\infty}^{x} f(t)\, dt.$$

Internally, `pdf_to_cdf()` evaluates this integral at each point using R's
`stats::integrate()`, which applies adaptive Gauss--Kronrod quadrature:

```r
pdf_to_cdf <- function(pdf_fun, lower = -Inf) {
  function(x) {
    vapply(x, function(xi) {
      res <- try(
        stats::integrate(pdf_fun, lower = lower, upper = xi,
                         stop.on.error = FALSE),
        silent = TRUE
      )
      if (inherits(res, "try-error")) NA_real_ else res$value
    }, numeric(1))
  }
}
```

Each evaluation point requires a separate call to `integrate()`, so this is the
most computationally expensive conversion. For distributions with known finite
lower bounds (e.g. the exponential), setting `lower = 0` avoids integrating over
an infinite domain and improves both speed and accuracy.

**Accuracy.** For smooth, well-behaved densities the absolute error is typically
below $10^{-6}$, well within plotting resolution. Densities with
singularities (e.g. the Beta(0.5, 0.5) density, which diverges at 0 and 1) may
produce larger errors near the singular points.

### CDF to PDF: central finite differences

Given a CDF $F$, the PDF is its derivative $f(x) = F'(x)$. Internally,
`cdf_to_pdf()` approximates this with a central difference:

$$f(x) \approx \frac{F(x + h) - F(x - h)}{2h}$$

with step size $h = 10^{-5}$:

```r
cdf_to_pdf <- function(cdf_fun, h = 1e-5) {
  function(x) {
    (cdf_fun(x + h) - cdf_fun(x - h)) / (2 * h)
  }
}
```

This is fast and naturally vectorized---a single call evaluates all grid points
at once.

**Accuracy.** The central difference has $O(h^2)$ truncation error, so with
$h = 10^{-5}$ the error is roughly $10^{-10}$ for smooth CDFs. In practice the
dominant error source is floating-point cancellation when $F(x+h) \approx
F(x-h)$, which occurs in the extreme tails where the CDF is nearly flat. This
is harmless for plotting because the density is negligibly small in those
regions.

### CDF to quantile function: root-finding

Given a CDF $F$, the quantile function solves $F(x) = p$ for each probability
$p \in (0, 1)$. Internally, `cdf_to_qf()` uses `stats::uniroot()` to find the
root of $g(x) = F(x) - p$:

```r
cdf_to_qf <- function(cdf_fun, search_lower = -10, search_upper = 10) {
  function(p) {
    vapply(p, function(pi) {
      if (pi <= 0) return(-Inf)
      if (pi >= 1) return(Inf)

      lo <- search_lower; hi <- search_upper

      # Adaptively widen bounds until they bracket the target
      for (i in 1:25) {
        if (!is.na(cdf_fun(lo)) && cdf_fun(lo) <= pi) break
        lo <- lo * 2
      }
      for (i in 1:25) {
        if (!is.na(cdf_fun(hi)) && cdf_fun(hi) >= pi) break
        hi <- hi * 2
      }

      res <- try(
        stats::uniroot(function(x) cdf_fun(x) - pi,
                       lower = lo, upper = hi,
                       tol = .Machine$double.eps^0.5),
        silent = TRUE
      )
      if (inherits(res, "try-error")) NA_real_ else res$root
    }, numeric(1))
  }
}
```

The algorithm starts with initial search bounds $[-10, 10]$ and adaptively
doubles them until the CDF values bracket the target probability. This handles
distributions with arbitrary support without requiring the user to specify
bounds. The boundary cases $p = 0$ and $p = 1$ return $-\infty$ and $+\infty$
directly.

**Accuracy.** `uniroot()` converges to machine precision
($\approx 1.5 \times 10^{-8}$), so the quantile values are effectively exact.
The main cost is one CDF evaluation per `uniroot()` iteration (typically 10--20
iterations), applied independently at each probability point.

### Survival to CDF: exact arithmetic

Given a survival function $S(x) = 1 - F(x)$, the CDF is recovered by simple
subtraction:

$$F(x) = 1 - S(x).$$

Internally, `survival_to_cdf()` wraps this in a closure:

```r
survival_to_cdf <- function(survival_fun) {
  function(x) 1 - survival_fun(x)
}
```

**Accuracy.** This conversion is exact (up to floating-point rounding), with
errors on the order of machine epsilon ($\approx 2.2 \times 10^{-16}$).

### Quantile function to CDF: interpolation

Given a quantile function $Q(p)$, the CDF can be recovered by inverting the
relationship: evaluate $Q$ on a dense grid of probabilities $p_1, \ldots, p_n$
to get the corresponding $x$ values, then interpolate. Internally,
`qf_to_cdf()` uses `stats::approxfun()` with `rule = 2` (constant
extrapolation at boundaries):

```r
qf_to_cdf <- function(qf_fun, n = 10000) {
  p_grid <- seq(1 / (n + 1), n / (n + 1), length.out = n)
  x_grid <- qf_fun(p_grid)
  stats::approxfun(x_grid, p_grid, rule = 2)
}
```

The grid avoids $p = 0$ and $p = 1$ (which would map to $\pm\infty$ for
unbounded distributions). With $n = 10{,}000$ grid points, the interpolation
error is typically below $10^{-3}$ for smooth distributions.

**Accuracy.** Linear interpolation on $10{,}000$ points gives roughly three
decimal digits of accuracy. This is more than sufficient for plotting, though
downstream differentiation (e.g. to obtain a PDF) amplifies the error by one
order of magnitude.

### Hazard to CDF: numerical integration

Given a hazard function $h$, the cumulative hazard is $H(x) = \int_{-\infty}^{x} h(t)\, dt$
and the CDF follows as $F(x) = 1 - e^{-H(x)}$. Internally, `hf_to_cdf()` computes
$H(x)$ via `stats::integrate()` and applies the exponential transform:

```r
hf_to_cdf <- function(hf_fun, lower = -Inf) {
  function(x) {
    vapply(x, function(xi) {
      res <- try(
        stats::integrate(hf_fun, lower = lower, upper = xi,
                         stop.on.error = FALSE),
        silent = TRUE
      )
      if (inherits(res, "try-error")) NA_real_ else 1 - exp(-res$value)
    }, numeric(1))
  }
}
```

**Accuracy.** Similar to `pdf_to_cdf`, each evaluation point requires a call to
`integrate()`. Absolute error is typically below $10^{-6}$ for smooth hazard
functions.

### Hazard to PDF: direct formula

Rather than chaining `hf_to_cdf` + `cdf_to_pdf` (which nests numerical
operations and can be unstable), `hf_to_pdf()` applies the identity
$f(x) = h(x) \cdot e^{-H(x)}$ directly:

```r
hf_to_pdf <- function(hf_fun, lower = -Inf) {
  function(x) {
    vapply(x, function(xi) {
      res <- try(
        stats::integrate(hf_fun, lower = lower, upper = xi,
                         stop.on.error = FALSE),
        silent = TRUE
      )
      if (inherits(res, "try-error")) return(NA_real_)
      hf_fun(xi) * exp(-res$value)
    }, numeric(1))
  }
}
```

This avoids the finite-difference step entirely, producing a more accurate
derived PDF.

**Accuracy.** For smooth hazard functions the error is comparable to
`pdf_to_cdf`---typically below $10^{-6}$.

### Chained conversions

Some geoms require two conversions in sequence. For example,
`geom_qf(pdf_fun = ...)` first integrates the PDF to obtain a CDF
(`pdf_to_cdf`), then inverts that CDF by root-finding (`cdf_to_qf`). Each
root-finding step calls the derived CDF, which itself calls `integrate()`. This
double nesting makes it the most expensive path, but the cost is still modest
for the default $n = 101$ evaluation points.

Similarly, `geom_survival(pdf_fun = ...)` integrates the PDF to get $F$, then
computes $S(x) = 1 - F(x)$. And when `geom_hf()` receives only `pdf_fun`, it
derives the CDF by integration so that it can compute $h(x) = f(x) / (1 -
F(x))$.

The new `survival_fun` and `qf_fun` paths also produce chains:
`geom_pdf(survival_fun = ...)` computes $F = 1 - S$ (exact), then differentiates
to get $f$. `geom_pdf(qf_fun = ...)` interpolates $Q$ to get $F$, then
differentiates. `geom_qf(survival_fun = ...)` computes $F = 1 - S$, then
inverts by root-finding.

## Accuracy comparison

We can compare derived values against the exact analytic functions to see the
conversion error in practice. Here we use the standard normal distribution:

```{r accuracy, fig.width = 10, fig.height = 4}
# CDF derived from PDF vs exact
p1 <- ggplot() +
  geom_cdf(pdf_fun = dnorm, xlim = c(-3, 3)) +
  geom_cdf(fun = pnorm, xlim = c(-3, 3), color = "red", linetype = "dashed") +
  ggtitle("CDF: derived (black) vs exact (red)")

# PDF derived from CDF vs exact
p2 <- ggplot() +
  geom_pdf(cdf_fun = pnorm, xlim = c(-3, 3)) +
  geom_pdf(fun = dnorm, xlim = c(-3, 3), color = "red", alpha = 0) +
  ggtitle("PDF: derived (black) vs exact (red)")

# QF derived from CDF vs exact
p3 <- ggplot() +
  geom_qf(cdf_fun = pnorm) +
  geom_qf(fun = qnorm, color = "red", linetype = "dashed") +
  ggtitle("QF: derived (black) vs exact (red)")

p1 | p2 | p3
```

The derived curves (black) are visually indistinguishable from the exact curves
(red dashed), confirming that the numerical methods are accurate enough for
plotting.

## Example: from a survival function

Suppose you only have the survival function of an exponential distribution:

```{r surv-example, fig.width = 10, fig.height = 4}
my_surv <- function(x, rate) 1 - pexp(x, rate = rate)

p1 <- ggplot() +
  geom_cdf(survival_fun = my_surv, xlim = c(0, 5), args = list(rate = 1)) +
  ggtitle("CDF (from survival)")

p2 <- ggplot() +
  geom_pdf(survival_fun = my_surv, xlim = c(0, 5), args = list(rate = 1)) +
  ggtitle("PDF (from survival)")

p3 <- ggplot() +
  geom_qf(survival_fun = my_surv, args = list(rate = 1)) +
  ggtitle("QF (from survival)")

p1 | p2 | p3
```

## Example: from a quantile function

Similarly, if you only have a quantile function:

```{r qf-example, fig.width = 10, fig.height = 4}
p1 <- ggplot() +
  geom_cdf(qf_fun = qnorm, xlim = c(-3, 3)) +
  ggtitle("CDF (from QF)")

p2 <- ggplot() +
  geom_pdf(qf_fun = qnorm, xlim = c(-3, 3)) +
  ggtitle("PDF (from QF)")

p3 <- ggplot() +
  geom_survival(qf_fun = qnorm, xlim = c(-3, 3)) +
  ggtitle("Survival (from QF)")

p1 | p2 | p3
```

## Example: from a hazard function

Suppose you only have the hazard function of a Weibull distribution:

```{r hf-example, fig.width = 10, fig.height = 4}
h_weibull <- function(x, shape, scale) {
  dweibull(x, shape = shape, scale = scale) / pweibull(x, shape = shape, scale = scale, lower.tail = FALSE)
}

p1 <- ggplot() +
  geom_pdf(hf_fun = h_weibull, xlim = c(0.01, 5), args = list(shape = 2, scale = 1)) +
  ggtitle("PDF (from hazard)")

p2 <- ggplot() +
  geom_cdf(hf_fun = h_weibull, xlim = c(0.01, 5), args = list(shape = 2, scale = 1)) +
  ggtitle("CDF (from hazard)")

p3 <- ggplot() +
  geom_chf(hf_fun = h_weibull, xlim = c(0.01, 5), args = list(shape = 2, scale = 1)) +
  ggtitle("Cumulative hazard (from hazard)")

p1 | p2 | p3
```

## Example: cumulative hazard function

`geom_chf()` accepts any of the six standard function types. Here we show the
cumulative hazard derived from a CDF, a survival function, and a hazard function:

```{r chf-example, fig.width = 10, fig.height = 4}
p1 <- ggplot() +
  geom_chf(cdf_fun = pexp, xlim = c(0, 5), args = list(rate = 1)) +
  ggtitle("H(x) from CDF")

p2 <- ggplot() +
  geom_chf(survival_fun = function(x, rate) exp(-rate * x),
           xlim = c(0, 5), args = list(rate = 1)) +
  ggtitle("H(x) from survival")

p3 <- ggplot() +
  geom_chf(hf_fun = function(x) ifelse(x >= 0, 1, 0), xlim = c(0, 5)) +
  ggtitle("H(x) from hazard")

p1 | p2 | p3
```

For the exponential distribution with rate 1, $H(x) = x$---a straight line
confirming the constant hazard.

## Performance considerations

- **Integration** (`pdf_to_cdf`): $O(n)$ calls to `integrate()`, each with
  $O(k)$ function evaluations where $k$ depends on the integrand's smoothness.
  Typically the slowest single conversion.
- **Differentiation** (`cdf_to_pdf`): A single vectorized evaluation---two CDF
  calls total. Essentially free.
- **Root-finding** (`cdf_to_qf`): $O(n)$ calls to `uniroot()`, each requiring
  $O(m)$ CDF evaluations ($m \approx 15$). Comparable to integration in cost.
- **Survival to CDF** (`survival_to_cdf`): A single vectorized
  evaluation---one subtraction per point. Essentially free.
- **QF to CDF** (`qf_to_cdf`): One-time cost of evaluating the quantile
  function on 10,000 grid points to build the interpolation table. After
  setup, CDF lookups are $O(1)$ via `approxfun()`.
- **Hazard to CDF** (`hf_to_cdf`): $O(n)$ calls to `integrate()`, comparable
  to `pdf_to_cdf`.
- **Hazard to PDF** (`hf_to_pdf`): $O(n)$ calls to `integrate()` plus one
  hazard evaluation per point. Slightly more expensive than `pdf_to_cdf` but
  avoids the instability of chaining `hf_to_cdf` + `cdf_to_pdf`.
- **Chained** (`pdf_fun` to quantile): $O(n \cdot m)$ calls to `integrate()`.
  The most expensive path but still completes in under a second for the default
  $n = 101$.

When speed matters or when working with distributions that have analytic forms
for multiple function types, supplying the native function directly avoids all
conversion overhead. For example, `geom_cdf(fun = pnorm)` is faster than
`geom_cdf(pdf_fun = dnorm)`, though both produce visually identical output.

## The discrete case

Discrete geoms (`geom_cdf_discrete`, `geom_survival_discrete`,
`geom_qf_discrete`) perform exact arithmetic rather than numerical
approximation:

- **PMF to CDF**: cumulative summation of the PMF values over the integer (or
  explicit) support. This is exact up to floating-point rounding.
- **PMF to survival**: cumulative summation followed by $S(x) = 1 - F(x)$.
  Again exact.
- **CDF to quantile (discrete)**: the CDF is evaluated at each support point
  and the step function is inverted directly. No root-finding is needed.
- **Survival to CDF (discrete)**: $F(x) = 1 - S(x)$ on each support point.
  Exact.
- **Survival to quantile (discrete)**: $F(x) = 1 - S(x)$ on each support
  point, then invert. Exact.

These operations introduce no approximation error, so there is no accuracy
trade-off for discrete conversions.
